\chapter{Исследовательский раздел}

В данном разделе будут проведены сравнения реализаций алгоритмов сортировки  по времени работы и по затрачиваемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором проводились исследования: 

\begin{itemize}[label=--]
	\item операционная система: Ubuntu 22.04.3 LTS x86\_64 \cite{os};
	\item оперативная память: 16 Гб;
	\item процессор: 11th Gen Intel® Core™ i7-1185G7 @ 3.00 ГГц × 8.
\end{itemize}

\section{Время выполнения алгоритмов}

Время работы алгоритмов измерялось с использованием функции $clock\_gettime$ из встроенного модуля $ctime$. 

Замеры времени для каждого размера 1000 раз.

\subsection{Массив случайно сгенерированных чисел заданного размера}

На вход подавались случайно сгенерированные векторы заданного размера.

Исходя из полученных данных, самыми быстрыми алгоритмами сортировки из всех трех являются алгоритм поразрядной сортировки и блочной сортировки: средняя разница во времени сортировки этих двух алгоритмов составляет порядка 5 мкс, на некоторых значениях быстрее один алгоритм, на других -- другой. Это связано с тем, что в этих двух алгоритмах создается всего по одному динамическому подмассиву для хранения данных, в то время как в алгоритме сортировки слиянием при каждом рекурсивном вызове создается два подмассива для хранения левой и правой отсортированных частей при слиянии. 

Также важную роль в результатах времени работы блочной сортировки играет алгоритм, с помощью которого сортируется каждый сформированный блок. Для сортировки блоков была использована функция $std::sort$ из заголовочного файла <<$algorithm$>> библиотеки языка $C++$, что существенно уменьшает время работы блочной сортировки.

Данные представлены в таблице \ref{tbl:timeRand}. Их графическое отображение представлено на рисунке \ref{img:timeSortRand}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для массивов размеров от 100 до 1000 элементов}
			\label{tbl:timeRand}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мкс} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 20.914 & 24.570 & 22.775 \\
				\hline
				200 & 44.529 & 55.438 & 44.095 \\
				\hline
				300 & 65.092 & 83.636 & 69.413 \\
				\hline
				400 & 90.714 & 117.511 & 95.950 \\
				\hline
				500 & 109.428 & 145.115 & 114.910 \\
				\hline
				600 & 134.144 & 179.441 & 134.590 \\
				\hline
				700 & 162.905 & 218.916 & 162.367 \\
				\hline
				800 & 186.143 & 255.873 & 180.051 \\
				\hline
				900 & 204.253 & 299.945 & 213.199 \\
				\hline
				1000 & 226.394 & 319.310 & 225.048 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{timeSortRand} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\subsection{Массив случайно сгенерированных чисел заданного размера, отсортированный по возрастанию элементов}

На вход подавались случайно сгенерированные векторы заданного размера, отсортированные по возрастанию элементов.

В отличие от данных, полученных в предыдущем исследовании, эти данные позволяют точно определить самый быстрый алгоритм сортировки из всех трех -- алгоритм блочной сортировки. Хоть средняя разница во времени между алгоритмом блочной сортировки и поразрядной сортировки сохранила свое значение порядка 5 мкс, но на каждой из рассмотренных размерностей массива алгоритм блочной сортировки оказывался быстрее. Это связано с тем, что в алгоритме поразрядной сортировки сортировка начинается с младших разрядов, что значения которых в отсортированном массиве могут быть не упорядочены, а в алгоритме блочной сортировки все каждое значение уже отсортированного массива попадает в свою собственный блок, где сортируется за $O(1)$ и возвращается в исходный массив в том же порядке.

Также важную роль в результатах времени работы блочной сортировки играет алгоритм, с помощью которого сортируется каждый сформированный блок. Для сортировки блоков была использована функция $std::sort$ из заголовочного файла <<$algorithm$>> библиотеки языка $C++$, что существенно уменьшает время работы блочной сортировки.

Алгоритм сортировки слиянием оказался медленнее рассмотренных выше алгоритмов. Это связано с тем, что в этих двух алгоритмах создается всего по одному динамическому подмассиву для хранения данных, в то время как в алгоритме сортировки слиянием при каждом рекурсивном вызове создается два подмассива для хранения левой и правой отсортированных частей при слиянии.

Данные представлены в таблице \ref{tbl:timeAsc}. Их графическое отображение представлено на рисунке \ref{img:timeSortAsc}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для массивов размеров от 100 до 1000 элементов}
			\label{tbl:timeAsc}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мкс} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 20.878 & 21.533 & 22.429 \\
				\hline
				200 & 40.743 & 46.217 & 44.154 \\
				\hline
				300 & 60.475 & 69.919 & 64.169 \\
				\hline
				400 & 83.173 & 98.500 & 90.431 \\
				\hline
				500 & 104.820 & 125.650 & 112.199 \\
				\hline
				600 & 122.446 & 151.872 & 135.148 \\
				\hline
				700 & 142.568 & 175.570 & 155.219 \\
				\hline
				800 & 164.111 & 201.655 & 169.880 \\
				\hline
				900 & 190.310 & 232.209 & 199.635 \\
				\hline
				1000 & 211.530 & 253.790 & 215.852 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{timeSortAsc} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка


\subsection{Массив случайно сгенерированных чисел заданного размера, отсортированный по убыванию элементов}

На вход подавались случайно сгенерированные векторы заданного размера, отсортированные по убыванию элементов.

Исходя из полученных данных, самыми быстрыми алгоритмами сортировки из всех трех являются алгоритм поразрядной сортировки и блочной сортировки: средняя разница во времени сортировки этих двух алгоритмов составляет порядка 5 мкс, на некоторых значениях быстрее один алгоритм, на других -- другой. Это связано с тем, что в этих двух алгоритмах создается всего по одному динамическому подмассиву для хранения данных, в то время как в алгоритме сортировки слиянием при каждом рекурсивном вызове создается два подмассива для хранения левой и правой отсортированных частей при слиянии. 

Также важную роль в результатах времени работы блочной сортировки играет алгоритм, с помощью которого сортируется каждый сформированный блок. Для сортировки блоков была использована функция $std::sort$ из заголовочного файла <<$algorithm$>> библиотеки языка $C++$, что существенно уменьшает время работы блочной сортировки.

Алгоритм сортировки слиянием на размерах массива, больших ста, оказался медленнее рассмотренных выше алгоритмов. Это связано с тем, что в этих двух алгоритмах создается всего по одному динамическому подмассиву для хранения данных, в то время как в алгоритме сортировки слиянием при каждом рекурсивном вызове создается два подмассива для хранения левой и правой отсортированных частей при слиянии.

Однако, на размере массива в 100 элементов можно увидеть, что алгоритм сортировки слиянием работает быстрее остальных алгоритмов.

Данные представлены в таблице \ref{tbl:timeDesc}. Их графическое отображение представлено на рисунке \ref{img:timeSortAsc}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для массивов размеров от 100 до 1000 элементов}
			\label{tbl:timeDesc}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мкс} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 23.647 & 22.608 & 24.341 \\
				\hline
				200 & 44.744 & 47.338 & 46.256 \\
				\hline
				300 & 67.371 & 73.604 & 69.102 \\
				\hline
				400 & 89.571 & 103.810 & 93.015 \\
				\hline
				500 & 111.640 & 126.591 & 111.817 \\
				\hline
				600 & 133.385 & 157.268 & 145.395 \\
				\hline
				700 & 162.672 & 186.137 & 160.111 \\
				\hline
				800 & 178.832 & 211.646 & 181.307 \\
				\hline
				900 & 204.869 & 239.801 & 204.348 \\
				\hline
				1000 & 227.685 & 266.782 & 224.748 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\includesvgimage
{timeSortDesc} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\clearpage

\subsection{Массив, состоящий из одинаковых элементов}

На вход подавались массивы заданного размера, состоящие из одинаковых элементов.

Исходя из полученных данных, можно увидеть, что самый быстрый алгоритм сортировки из всех трех -- алгоритм блочной сортировки. Это связано с тем, что в алгоритме блочной сортировки все значения массива попадают в один блок, где сортируются функцией $std::sort$ из заголовочного файла <<$algorithm$>> библиотеки языка $C++$, что существенно уменьшает время работы блочной сортировки.

Алгоритм сортировки слиянием оказался медленнее рассмотренных выше алгоритмов. Это связано с тем, что в этих двух алгоритмах создается всего по одному динамическому подмассиву для хранения данных, в то время как в алгоритме сортировки слиянием при каждом рекурсивном вызове создается два подмассива для хранения левой и правой отсортированных частей при слиянии.

Однако, на размере массива в 100 элементов можно увидеть, что алгоритм сортировки слиянием работает быстрее алгоритма поразрядной сортировки.

Данные представлены в таблице \ref{tbl:timeSame}. Их графическое отображение представлено на рисунке \ref{img:timeSortAsc}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для массивов размеров от 100 до 1000 элементов}
			\label{tbl:timeSame}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мкс} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 13.632 & 22.066 & 23.332 \\
				\hline
				200 & 28.923 & 46.919 & 44.327 \\
				\hline
				300 & 49.952 & 77.532 & 73.044 \\
				\hline
				400 & 68.537 & 106.991 & 92.550 \\
				\hline
				500 & 82.382 & 130.768 & 112.892 \\
				\hline
				600 & 110.334 & 165.079 & 139.385 \\
				\hline
				700 & 121.641 & 184.348 & 166.654 \\
				\hline
				800 & 154.355 & 221.561 & 186.757 \\
				\hline
				900 & 157.712 & 253.447 & 212.145 \\
				\hline
				1000 & 176.284 & 268.412 & 231.275 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\includesvgimage
{timeSortSame} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\clearpage

\section{Использование памяти}

Анализируя полученные данные можно увидеть, что самым эффективным по памяти является является алгоритм блочной сортировки. Это обусловлено тем, что в
этом алгоритме создается всего один дополнительный массив блоков, в который по которым равномерно распределяются элементы массива, в то время как для работы других алгоритмов сортировки необходимо минимум два дополнительных массива данных.

Алгоритм сортировки слиянием, как и в случае с оценкой алгоритмов по времени,
является самым не эффективным: при размере массива в 100 элементов он расходует памяти в среднем в 1.4 раза больше, чем любой другой алгоритм. Это связано стем, что при каждом рекурсивном вызове при слиянии двух отсортированных подмассивов выделяется память под их хранение.

Данные представлены в таблице \ref{tbl:mem}. Их графическое отображение представлено на рисунке \ref{img:timeSort}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер используемой памяти для массивов размеров от 100 до 1000 элементов}
			\label{tbl:mem}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Память, байты} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 880 & 1 280 & 932 \\
				\hline
				200 & 1 680 & 2 164 & 1 732 \\
				\hline
				300 & 2 480 & 3 040 & 2 532 \\
				\hline
				400 & 3 280 & 3 848 & 3 332 \\
				\hline
				500 & 4 080 & 4 624 & 4 132 \\
				\hline
				600 & 4 880 & 5 524 & 4 932 \\
				\hline
				700 & 5 680 & 6 308 & 5 732 \\
				\hline
				800 & 6 480 & 7 132 & 6 532 \\
				\hline
				900 & 7 280 & 7 924 & 7 332 \\
				\hline
				1000 & 8 080 & 8 708 & 8 132 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{memSort} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров работы используемой памяти алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\section*{Вывод}

В данном разделе были проведены замеры времени работы, а также расчеты используемой памяти реализаций алгоритмов сортировки. 

Самым эффективным по обоим параметрам оказался алгоритм блочной сортировки, самым неэффективным по обоим параметрам оказался алгоритм сортировки слиянием. Полученные результаты для алгоритма поразрядной сортировки показали, что он выполняет сортировку почти также быстро, как алгоритм блочной сортировки. Алгоритм поразрядной сортировки немного проигрывает по расходу памяти алгоритму блочной сортировки, но выигрывает у алгоритма сортировки слиянием.

