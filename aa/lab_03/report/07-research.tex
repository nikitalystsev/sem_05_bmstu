\chapter{Исследовательский раздел}

В данном разделе будут проведены сравнения реализаций алгоритмов умножения матриц 
по времени работы и по затрачиваемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором проводились исследования: 

\begin{itemize}[label=--]
	\item операционная система: Ubuntu 22.04.3 LTS x86\_64 \cite{os};
	\item оперативная память: 16 Гб;
	\item процессор: 11th Gen Intel® Core™ i7-1185G7 @ 3.00GHz × 8.
\end{itemize}

\section{Время выполнения алгоритмов}

Время работы алгоритмов измерялось с использованием функции $clock\_gettime$ из встроенного модуля $ctime$. 

Замеры времени для каждого размера матрицы проводились 1000 раз. На вход подавались случайно сгенерированные матрицы заданного размера. 

Результаты замеров реализаций алгоритмов по времени представлены в таблице \ref{tbl:time}. Их графическое представление показано на рисунке \ref{img:linear_graph_time}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер памяти для матриц размером от 10 до 100}
			\label{tbl:time}
			\begin{tabular}{|c|c|c|c|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, нс} \\ \cline{2-4}
				\bfseries Линейный размер, штуки & \bfseries Классический & \bfseries Виноград & \bfseries Виноград (опт)  \\ \cline{2-4}
				\hline
				10 & 3416.896 & 3180.420 & 3134.480  \\
				\hline
				20 & 29545.140 & 22744.160 & 21871.700  \\
				\hline
				30 & 94943.940 & 74144.360 & 73816.280  \\
				\hline
				40 & 218554.000 & 177503.000 & 169667.400 \\
				\hline
				50 & 433830.200 & 345092.400 & 332352.600 \\
				\hline
				60 &  742386.600 & 588659.800 & 574165.200  \\
				\hline
				70 & 1150328.000 & 930386.000 & 915796.200  \\
				\hline
				80 & 1718110.000 & 1381020.000 & 1344386.000  \\
				\hline
				90 & 2463566.000 & 1984904.000 & 1919098.000  \\
				\hline
				100 & 3386088.000 & 2715484.000 & 2632198.000  \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\begin{figure}[h]
	\centering
	\includesvg[width=0.9\textwidth]{linear_graph_time}
	\caption{Результаты замеров времени работы алгоритмов для матриц размеров от 10 до 100}
	\label{img:linear_graph_time}
\end{figure}




\clearpage


\section{Использование памяти}

Введем следующие обозначения:
\begin{itemize}[label=--]
	\item$l_1$ --- длина строки $S_{1}$;
	\item$l_2$ --- длина строки $S_{2}$;
	\item$sizeof()$ --- функция вычисляющая размер в байтах;
	\item $wstring$ --- строковый тип;
	\item $int$ --- целочисленный тип;
	\item $size\_t$ --- беззнаковый целочисленный тип.
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации нахождения расстояния Дамерау-Левенштейна равна сумме входящих строк, а на каждый вызов требуется 2 дополнительные переменные, соответственно, максимальный расход памяти равен:

\begin{equation}
	\label{eq:dl_rec_memory}
	(l_1 + l_2) \cdot ( 2 \cdot sizeof(size\_t)  + 2 \cdot sizeof(int)) + 2 * sizeof(wstring),
\end{equation}

где:
\begin{itemize}[label=--]
	\item $2 \cdot sizeof(size\_t)$ --- хранение размеров строк;
	\item $2 \cdot sizeof(int)$ --- дополнительные переменные;
	\item $2 \cdot sizeof(wstring)$ --- хранение двух строк.
\end{itemize}

Расчет используемой памяти для рекурсивного алгоритма c кешированием поиска расстояния Дамерау-Левенштейна будет теоретически схож с расчетом в формуле \ref{eq:dl_rec_memory}, но также учитывается матрица, соответственно, максимальный расход памяти равен:

\begin{equation}
	\label{eq:dl_hash_memory}
	\begin{aligned}
		(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int) + sizeof(int **) + (l_1 + 1) \cdot sizeof(int *) + \\
		(l_1 + l_2) \cdot (2 \cdot sizeof(size\_t) + sizeof(int)) + 2 \cdot sizeof(wstring)
	\end{aligned}
\end{equation}

где 
\begin{itemize} [label=--]
	\item $(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение матрицы;
	\item $sizeof(int **)$ -- указатель на матрицу;
	\item $(l_1 + 1) \cdot sizeof(int *)$ -- указатель на строки матрицы;
	\item $2 \cdot size(size\_t)$ --- хранение размеров строк;
	\item $sizeof(int)$ --- дополнительная переменная;
	\item $2 * sizeof(wstring)$ --- хранение двух строк.
\end{itemize}

Расчет использования памяти при итеративной реализации алгоритма поиска расстояния Левенштейна теоретически равен:

\begin{equation}
	\label{eq:lev_mtr_memory}
	\begin{aligned}
		2 \cdot (l_2 + 1) \cdot sizeof(int) +  2 \cdot sizeof(wstring) + \\
		 2 \cdot sizeof(size\_t) + sizeof(int),
	\end{aligned}
\end{equation}

где 
\begin{itemize}[label=--]
	\item $2 \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение двух массивов;
	\item $2 \cdot size(wstring)$ --- хранение двух строк;
	\item $2 \cdot sizeof(size\_t)$ --- хранение размеров строк;
	\item $sizeof(int)$ --- дополнительная переменная.
\end{itemize}

Расчет использования памяти при итеративной реализации алгоритма поиска расстояния Дамерау-Левенштейна теоретически равен:

\begin{equation}
	\label{eq:dl_mtr_memory}
	\begin{aligned}
		(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int) + sizeof(int **) + (l_1 + 1) \cdot sizeof(int *) +  \\
		2 \cdot sizeof(wstring) + 2 \cdot sizeof(size\_t) + sizeof(int),
	\end{aligned}
\end{equation}

где 
\begin{itemize} [label=--]
	\item $(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение матрицы;
	\item $sizeof(int **)$ -- указатель на матрицу;
	\item $(l_1 + 1) \cdot sizeof(int *)$ -- указатель на строки матрицы;
	\item $2 * sizeof(wstring)$ --- хранение двух строк;
	\item $2 \cdot size(size\_t)$ --- хранение размеров матрицы;
	\item $sizeof(int)$ --- дополнительная переменная.
\end{itemize}

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер памяти для строк, размером от 10 до 200}
			\label{tbl:memory}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Размер, байты} \\ \cline{2-5}
				& \multicolumn{1}{c|}{\bfseries Левенштейн}
				& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейн} \\ \cline{2-5}
				\bfseries Длина, символ & \bfseries Итеративный & \bfseries Итеративный & \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{4-5}
				& & & \bfseries Без кеша & \bfseries С кешом \\
				\hline
				10 & 252 & 748 & 624 & 1128 \\
				\hline
				20 & 412 & 2188 & 1184 & 2968 \\
				\hline
				30 & 572 & 4428 & 1744 & 5608 \\
				\hline
				40 & 732 & 7468 & 2304 & 9048 \\
				\hline
				50 & 892 & 11308 & 2864 & 13288 \\
				\hline
				60 &  1052 & 15948 & 3424 & 18328 \\
				\hline
				70 & 1212 & 21388 & 3984 & 24168 \\
				\hline
				80 &1372 & 27628 & 4544 & 30808 \\
				\hline
				90 & 1532 & 34668 & 5104 &  38248 \\
				\hline
				100 & 1692 & 42508 & 5664 & 46488 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

%\begin{figure}[h]
%	\centering
%	\includesvg[width=0.9\textwidth]{linear_graph_mem}
%	\caption{Результаты вычислений используемой памяти реализаций алгоритмов для строк с длиной от 10 до 100}
%	\label{img:linear_graph_mem}
%\end{figure}


\clearpage

Анализируя таблицу \ref{tbl:memory}, сравним нерекурсивные реализации алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. При любой длине строки от 10 до 100 символов итеративный алгоритм поиска расстояния Левенштейна использует меньше памяти: при длине строки в 10 символов - в 3 раза меньше, а при длине строки в 100 символов уже в 25 раз. Такие результаты объясняются тем, что нерекурсивная реализация алгоритма поиска расстояния Дамерау-Левенштейна использует матрицу для сохранения ранее вычисленных значений, в то время как нерекурсивной реализации алгоритма поиска расстояния Левенштейна необходимы лишь текущая и предыдущая строки матрицы.

Сравнивая рекурсивную и рекурсивную с кешированием реализации алгоритмов поиска расстояний Левенштейна, можно увидеть, что использования матрицы в качестве кеша также приводит к быстрому росту используемой памяти в зависимости от длины входных строк.

При рассмотрении нерекурсивной и рекурсивной реализаций алгоритма поиска расстояний Дамерау-Левенштейна видно, что последняя с ростом длины строки использует в несколько раз меньше памяти, чем нерекурсивная: при длине строки в 10 символов -- в 1.2 раза меньше, а при длине строки в 100 символов -- в 7.5 раз меньше. Это связано с тем, что нерекурсивная реализация использует матрицу, в то время как рекурсивная использует только память, выделенную под локальные переменные при каждом рекурсивном вызове функции.

\section*{Вывод}

В данном разделе были проведены замеры времени работы а также расчеты используемой памяти реализаций алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. 

Итеративные реализации алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна работают быстрее рекурсивных, поскольку при итеративных реализациях не происходит многократного расчета одних и тех же промежуточных значений в ходе работы алгоритма.

Однако, рекурсивные алгоритмы более эффективные при использовании памяти, поскольку при использовании рекурсивной реализации происходит выделение памяти только под локальные переменные при каждом рекурсивном вызове.

Использование матрицы в качестве кеша в рекурсивной реализации алгоритма Дамерау-Левенштейна позволило сократить время работы алгоритма, но увеличило количество используемой памяти.

