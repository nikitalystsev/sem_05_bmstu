\chapter{Исследовательский раздел}

В данном разделе будут проведены сравнения реализаций алгоритмов сортировки  по времени работы и по затрачиваемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором проводились исследования: 

\begin{itemize}[label=--]
	\item операционная система: Ubuntu 22.04.3 LTS x86\_64 \cite{os};
	\item оперативная память: 16 Гб;
	\item процессор: 11th Gen Intel® Core™ i7-1185G7 @ 3.00 ГГц × 8.
\end{itemize}

\section{Время выполнения алгоритмов}

Время работы алгоритмов измерялось с использованием функции $clock\_gettime$ из встроенного модуля $ctime$. 

Замеры времени для каждого размера 1000 раз. На вход подавались случайно сгенерированные векторы заданного размера.


Исходя из полученных данных, наиболее быстрым алгоритмом сортировки из всех трех является алгоритм блочной сортировки: на больших размерах он работает в 1.5 раза быстрее алгоритма сортировки слиянием, в 1.04 раз быстрее алгоритма поразрядной сортировки. Алгоритм сортировки слиянием оказался самым неэффективным по времени среди всех алгоритмов.

Данные представлены в таблице \ref{tbl:time}. Их графическое отображение представлено на рисунке \ref{img:timeSort}.

\clearpage

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для массивов размеров от 100 до 1000 элементов}
			\label{tbl:time}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Время, мкс} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 21.984 & 24.079 & 23.367 \\
				\hline
				200 & 43.961 & 52.015 & 47.727 \\
				\hline
				300 & 66.580 & 90.222 & 69.285 \\
				\hline
				400 & 92.634 & 116.973 & 93.435 \\
				\hline
				500 & 113.289 & 148.954 & 116.621 \\
				\hline
				600 & 134.604 & 187.587 & 141.475 \\
				\hline
				700 & 157.763 & 216.882 & 165.108 \\
				\hline
				800 & 179.392 & 250.836 & 187.108 \\
				\hline
				900 & 205.149 & 292.716 & 211.348 \\
				\hline
				1000 & 221.511 & 332.679 & 231.352 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\includesvgimage
{timeSort} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\clearpage

\section{Использование памяти}

Анализируя полученные данные можно увидеть, что самым эффективным по памяти является является алгоритм блочной сортировки. Это обусловлено тем, что в
этом алгоритме создается всего один дополнительный массив блоков, в который по которым равномерно распределяются элементы массива, в то время как для работы других алгоритмов сортировки необходимо минимум два дополнительных массива данных.

Алгоритм сортировки слиянием, как и в случае с оценкой алгоритмов по времени,
является самым не эффективным: при размере массива в 100 элементов он расходует памяти в среднем в 1.4 раза больше, чем любой другой алгоритм. Это связано стем, что при каждом рекурсивном вызове при слиянии двух отсортированных подмассивов выделяется память под их хранение.

Данные представлены в таблице \ref{tbl:mem}. Их графическое отображение представлено на рисунке \ref{img:timeSort}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер используемой памяти для массивов размеров от 100 до 1000 элементов}
			\label{tbl:mem}
			\begin{tabular}{|r|r|r|r|}
				\hline
				& \multicolumn{3}{c|}{\bfseries Память, байты} \\ \cline{2-4}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Блочная & \bfseries Слиянием & \bfseries Поразрядная \\ \cline{2-4}
				\hline
				100 & 880 & 1 280 & 932 \\
				\hline
				200 & 1 680 & 2 164 & 1 732 \\
				\hline
				300 & 2 480 & 3 040 & 2 532 \\
				\hline
				400 & 3 280 & 3 848 & 3 332 \\
				\hline
				500 & 4 080 & 4 624 & 4 132 \\
				\hline
				600 & 4 880 & 5 524 & 4 932 \\
				\hline
				700 & 5 680 & 6 308 & 5 732 \\
				\hline
				800 & 6 480 & 7 132 & 6 532 \\
				\hline
				900 & 7 280 & 7 924 & 7 332 \\
				\hline
				1000 & 8 080 & 8 708 & 8 132 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{memSort} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров работы используемой памяти алгоритмов для массивом размеров от 100 до 1000 элементов} % Подпись рисунка

\section*{Вывод}

В данном разделе были проведены замеры времени работы, а также расчеты используемой памяти реализаций алгоритмов сортировки. 

Самым эффективным по обоим параметрам оказался алгоритм блочной сортировки, самым неэффективным по обоим параметрам оказался алгоритм сортировки слиянием. Полученные результаты для алгоритма поразрядной сортировки показали, что он выполняет сортировку почти также быстро, как алгоритм блочной сортировки. Алгоритм поразрядной сортировки немного проигрывает по расходу памяти алгоритму блочной сортировки, но выигрывает у алгоритма сортировки слиянием.

