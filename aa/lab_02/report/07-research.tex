\chapter{Исследовательский раздел}

В данном разделе будут проведены сравнения реализаций алгоритмов умножения матриц  по времени работы и по затрачиваемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором проводились исследования: 

\begin{itemize}[label=--]
	\item операционная система: Ubuntu 22.04.3 LTS x86\_64 \cite{os};
	\item оперативная память: 16 Гб;
	\item процессор: 11th Gen Intel® Core™ i7-1185G7 @ 3.00 ГГц × 8.
\end{itemize}

\section{Время выполнения алгоритмов}

Время работы алгоритмов измерялось с использованием функции $clock\_gettime$ из встроенного модуля $ctime$. 

Замеры времени для каждого размера матрицы проводились 1000 раз. На вход подавались случайно сгенерированные матрицы заданного размера. 

Исходя из полученных данных, что наиболее быстрым алгоритмом умножения из всех четырех является оптимизированный алгоритм Винограда: на больших размерах он работает в 1.64 раза быстрее классического алгоритма, в 1.25 раз быстрее своей стандартной версии, в 1.33 раза быстрее алгоритма Штрассена.

Алгоритм Штрассена оказался самым неэффективным по времени среди всех алгоритмов: на размерах матриц, отличных от степени двойки, он проигрывает всем остальным алгоритмам, а на больших размерах, являющихся размерами двойки, данный алгоритм быстрее классического всего в 1.22 раза.
Скачок на графике \ref{img:timeMatrixMul} у алгоритма Штрассена связан с тем, что на размерах, отличных от степени двойки, производится перевыделение памяти и увеличения размеров матриц до ближайшей большей степени двойки. Выиграть по времени у алгоритма Винограда и его оптимизированной версии не получилось ни на одной размерности матриц.

Данные представлены в таблице \ref{tbl:time}. Их графическое отображение представлено на рисунке \ref{img:timeMatrixMul}.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер времени для матриц размером от 8 до 256}
			\label{tbl:time}
			\begin{tabular}{|r|r|r|r|r|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Время, мкс} \\ \cline{2-5}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Классический & \bfseries Виноград & \bfseries Виноград (опт) & \bfseries Штрассен  \\ \cline{2-5}
				\hline
				8 & 6.21 & 6.35 & 6.19 & 6.22 \\
				\hline
				10 & 14.27 & 10.63 & 9.60 & 49.77 \\
				\hline
				16 & 44.47 & 37.21 & 34.00 & 47.09 \\
				\hline
				20 & 92.43 & 78.02 & 66.18 & 364.69 \\
				\hline
				32 & 363.93 & 298.19 & 251.25 & 365.21 \\
				\hline
				40 &  707.57 & 565.64 & 489.92 & 2 820.93 \\
				\hline
				50 & 1 352.12 & 1 109.68 & 927.32 & 2 884.98 \\
				\hline
				64 & 2 867.77 & 2 238.58 & 1 920.84 & 2 877.87 \\
				\hline
				80 & 5 463.36 & 4 403.55 & 3 695.43 & 22 619.08 \\
				\hline
				128 & 27 344.14 & 21 422.10 & 18 168.62 & 25 578.16 \\
				\hline
				256 & 218 888.80 & 167 395.60 & 133 006.20 & 178 033.00 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{timeMatrixMul} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров времени работы алгоритмов для  матриц размером от 8 до 256} % Подпись рисунка

\section{Использование памяти}

Анализируя полученные данные можно увидеть, что самым эффективным по памяти является классический алгоритм. Это обусловлено тем, что в этом алгоритме нет дополнительных переменных, которые нужны в других алгоритмах.

Алгоритм Штрассена, как и в случае с оценкой алгоритмов по времени, является самым не эффективным: при размере матриц $10 \times 10$ он расходует памяти в среднем в 11 раз больше, чем любой другой алгоритм. 
Это связано с тем, что при каждом рекурсивном вызове для подматриц выделяется память под их хранение, а также выделяется память для хранения матриц $M_i$, $i = \overline{1, 7}$.

Данные представлены в таблице \ref{tbl:mem}. Их графическое отображение представлено на рисунке \ref{img:memMatrixMul}.

\clearpage

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер памяти для матриц размером от 10 до 100}
			\label{tbl:mem}
			\begin{tabular}{|r|r|r|r|r|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Память, Кб} \\ \cline{2-5}
				\bfseries \makecell{Линейный размер, \\ штуки} & \bfseries Классический & \bfseries Виноград & \bfseries Виноград (опт) & \bfseries Штрассен  \\ \cline{2-5}
				\hline
				10 & 1.51 & 1.63 & 1.64 & 17.45 \\
				\hline
				20 & 5.26 & 5.46 & 5.47 & 88.61 \\
				\hline
				30 & 11.36 & 11.63 & 11.64 & 106.89 \\
				\hline
				40 & 19.79 & 20.15 & 20.16 & 438.78 \\
				\hline
				50 & 30.57 & 31.01 & 31.06 & 481.90 \\
				\hline
				60 &  43.70 & 44.21 & 44.22 & 534.40 \\
				\hline
				70 & 59.17 & 59.76 & 59.77 & 2 031.60 \\
				\hline
				80 & 76.98 & 77.65 & 77.66 & 2 120.66 \\
				\hline
				90 & 97.13 & 97.88 & 97.89 & 2 221.45 \\
				\hline
				100 & 119.63 & 120.46 & 120.46 & 2 333.95 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\includesvgimage
{memMatrixMul} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результаты замеров расходов памяти алгоритмов для матриц размером от 10 до 100} % Подпись рисунка

\clearpage

\section*{Вывод}


В данном разделе были проведены замеры времени работы, а также расчеты используемой памяти реализаций алгоритмов умножения матриц. 

Исходя из результатов, полученных при оценках памяти и времени работы алгоритмов, можно сказать, что самым эффективным по времени и по памяти является оптимизированная версия алгоритма Винограда, а самым неэффективным по тем же характеристикам является алгоритм Штрассена.

Применение оптимизаций замены умножения на 2 на побитовый сдвиг влево и замены выражения вида $x = x + k$ на выражение вида $x +\kern-0.25em= k$ в алгоритме Винограда позволили существенно уменьшить время работы алгоритма по сравнению с его неоптимизированной версией, однако расход используемой памяти был незначительно увеличен дополнительной 4-х байтовой целочисленной переменной.
