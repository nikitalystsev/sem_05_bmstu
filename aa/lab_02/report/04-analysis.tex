\chapter{Аналитический раздел}

В данном разделе будут рассмотрены понятия матрицы, умножения двух матриц, классический алгоритм умножения матриц и умножение матриц с помощью алгоритма Винограда и Штрассена.

\section{Матрица}

Матрица -- математический объект, записываемый в виде прямоугольной таблицы элементов кольца или поля (например, целых или комплексных чисел), которая представляет собой совокупность строк и столбцов, на пересечении которых находятся её элементы. Количество строк и столбцов матрицы задают размер матрицы \cite{Mtr}.


\begin{equation*}
	A_{m \times n} =
	\begin{pmatrix}
		a_{11} & a_{12} & \cdots & a_{1n} \\
		a_{21} & a_{22} & \cdots & a_{2n} \\
		\vdots  & \vdots  & \ddots & \vdots  \\
		a_{m1} & a_{m2} & \cdots & a_{mn}
	\end{pmatrix}
\end{equation*}

Для матрицы определены  следующие алгебраические операции: 

\begin{enumerate}[label={\arabic*)}]
	\item Cложение матриц, имеющих один и тот же размер.
	\item Умножение матрицы на число.
	\item Умножение матриц подходящего размера.
\end{enumerate}

Умножение двух матриц (обозначается: $AB$, реже $A \times B$) определяется следующим образом: каждый элемент результирующей матрицы -- это сумма произведений элементов соответствующих строк первой матрицы и столбца второй матрицы. При этом количество столбцов в первой матрице должно совпадать с количеством строк во второй матрице. Операция умножения матриц в общем случае не коммутативна, то есть $AB \neq BA$.

\section{Классический алгоритм умножения двух матриц}

Классический алгоритм умножение двух матриц вытекает из определения умножения двух матриц и реализует формулу \ref{eq:clmul}.  Асимптотическая сложность такого алгоритма $O(n^3)$ для двух матриц порядка $n \times n$ \cite{Classic}. 

Пусть даны две прямоугольные матрицы $A$ и $B$ размерности $m \times n$ и $n \times q$ соответственно:

\begin{equation*}
A = 
\begin{pmatrix} 
	a_{11} & a_{12} & \cdots & a_{1m} \\
	a_{21} & a_{22} & \cdots & a_{2m} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	a_{l1} & a_{l2} & \cdots & a_{lm}
\end{pmatrix},\;\;\;
B =   
\begin{pmatrix} 
	b_{11} & b_{12} & \cdots & b_{1n} \\
	b_{21} & b_{22} & \cdots & b_{2n} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	b_{m1} & b_{m2} & \cdots & b_{mn}
\end{pmatrix}.
\end{equation*}

Тогда матрица $C$ размерностью $m \times q$:

\begin{equation*}
C = 
\begin{pmatrix} 
	c_{11} & c_{12} & \cdots & c_{1q} \\
	c_{21} & c_{22} & \cdots & c_{2q} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	c_{m1} & c_{m2} & \cdots & c_{mq}
\end{pmatrix} 
\end{equation*}

где элемент результирующей матрицы $c_{ij}$ определяется так:

\begin{equation}
	\label{eq:clmul}
	c_{ij} = \sum_{k=1}^m a_{ik} \cdot b_{kj}
\end{equation}

\section{Алгоритм Винограда для умножения двух матриц}

Анализируя классический алгоритм умножения двух матриц, можно увидеть, что каждый элемент результирующей матрицы представляет собой скалярное произведение соответствующей строки и соответствующего столбца исходной матрицы.Можно заметить также, что такое умножение допускает предварительную обработку, позволяющую часть работы выполнить заранее \cite{Vin}. 

Рассмотрим 2 вектора: $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$.

\clearpage

Их скалярное произведение равно:

\begin{equation}
	\label{eq:vimul}
	V \cdot W = v_1 \cdot w_1 + v_2 \cdot w_2 + v_3 \cdot w_3 + v_3 \cdot w_3
\end{equation}

Это равенство можно переписать в виде:

\begin{equation}
	\label{eq:vinscal}
	\begin{gathered} 
		V \cdot W = (v_1 + w_2) \cdot (v_2 + w_1) + (v_3 + w_4) \cdot (v_4 + w_3) \\
		- v_1 \cdot v_2 - v_3 \cdot v_4 - w_1 \cdot w_2 - w_3 \cdot w_4
	\end{gathered}
\end{equation}


Несмотря на то что второе выражение требует вычисления большего количества операций, чем стандартный алгоритм: вместо четырех умножений - шесть, а вместо трех сложений - десять, последние слагаемые в формуле \ref{eq:vinscal} допускают предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй матрицы, что позволит для каждого элемента выполнять лишь два умножения и пять сложений, складывая затем только лишь с 2 предварительно посчитанными суммами соседних элементов текущих строк и столбцов. Из-за того, что операция сложения быстрее операции умножения в ЭВМ, на практике алгоритм должен работать быстрее стандартного.

В случае нечетного значения размера изначальной матрицы следует произвести еще одну операцию - добавление произведения последних элементов соответствующих строк и столбцов.

Алгоритм Винограда имеет асимптотическую сложность $O(n^{2.3755})$ для двух матриц порядка $n \times n$ \cite{Vin2}.

\section{Оптимизированный алгоритм Винограда для умножения двух матриц}

При программной реализации алгоритма Винограда предлагается выполнить следующие оптимизации: 

\begin{enumerate}[label={\arabic*)}]
	\item Заменить умножение на 2 на побитовый сдвиг влево.
	\item Заменить выражение вида $x = x + k$ на выражение вида $x +\kern-0.25em= k$.
	\item Значение $\frac{Q}{2}$, используемое в циклах расчета предварительных данных, вычислить заранее.
\end{enumerate}

\section{Алгоритм Штрассена для умножения двух матриц}

Алгоритм Штрассена -- альтернатива классическому алгоритму умножения матриц. Суть данного алгоритма заключается в сокращении числа умножений (вместо 8-ми умножений в классическом алгоритме 7 в алгоритме Штрассена) путем подсчета дополнительных сумм и разностей. Если классический алгоритм для умножения двух матриц порядка $n \times n$ имеет сложность $O(n^3)$, то метод Штрассена требует $O(n^{2.807})$ \cite{stras2}.

Алгоритм Штрассена работает с квадратными матрицами, размер которых можно представить в виде степени двойки. В случае, если это не так, то матрица дополняется нулевыми элементами до квадратной матрицы ближайшего корректного размера.

Пусть матрицы $A$ и $B$ -- квадратные матрицы размером $n \times n$, матрица $C$ -- матрица размером $n \times n$, являющаяся результатом умножения матриц $A$ и $B$, где $n$ -- число, являющееся степенью двойки.

Алгоритм  действий в алгоритме Штрассена:

\begin{enumerate}[label={\arabic*)}]
	\item Разделить входные матрицы $A$ и $B$ и выходную матрицу $C$ на подматрицы размером $\frac{n}{2} \times \frac{n}{2}$:
	
	\begin{equation*}
		A = 
		\begin{pmatrix} 
			a_{00} & a_{01}  \\
			a_{10} & a_{11}  \\ 
		\end{pmatrix},\;\;\;
		B =   
		\begin{pmatrix} 
			b_{00} & b_{01}  \\
			b_{10} & b_{11}  \\ 
		\end{pmatrix},\;\;\;
		C =   
		\begin{pmatrix} 
			c_{00} & c_{01}  \\
			c_{10} & c_{11}  \\ 
		\end{pmatrix}.
	\end{equation*}
	
	где $a_{ij}, b_{ij}, c_{ij} \hspace{0.25cm} i, j = \overline{0, 1}$ -- подматрицы размером $\frac{n}{2} \times \frac{n}{2}$;

	\item Вычислить матрицы $M_i$, $i = \overline{1, 7}$ по следующим формулам:
	
	\begin{equation}
		\label{eq:M1}
		M_1 = (a_{00} + a_{11}) \cdot (b_{00} + b_{11})
	\end{equation}

	\begin{equation}
		\label{eq:M2}
		M_2 = (a_{10} + a_{11}) \cdot b_{00}
	\end{equation}

	\begin{equation}
		\label{eq:M3}
		M_3 = (b_{01} - b_{11}) \cdot a_{00}
	\end{equation}
	
	\begin{equation}
		\label{eq:M4}
		M_4 = a_{11} \cdot (b_{10} - b_{00})
	\end{equation}

	\begin{equation}
		\label{eq:M5}
		M_5 = (a_{00} + a_{01}) \cdot b_{11}
	\end{equation}

	\begin{equation}
		\label{eq:M6}
		M_6 = (a_{10} - a_{00}) \cdot (b_{00} + b_{01})
	\end{equation}
		
	\begin{equation}
		\label{eq:M7}
		M_7 = (a_{01} - a_{11}) \cdot (b_{10} + b_{11})
	\end{equation}
	
	\item Вычислить подматрицы $c_{00}, c_{01}, c_{10}, c_{11}$ результирующей матрицы $C$ по следующим формулам:
	
	\begin{equation}
		\label{eq:c00}
		c_{00} = M_1 + M_4 - M_5 + M_7
	\end{equation}
	
	\begin{equation}
		\label{eq:c01}
		c_{01} = M_3 + M_5
	\end{equation}
	
	\begin{equation}
		\label{eq:c10}
		c_{10} = M_2 + M_4
	\end{equation}
	
	\begin{equation}
		\label{eq:c11}
		c_{11} = M_1 + M_3 - M_2 + M_6
	\end{equation}
\end{enumerate}

В программной реализации данного алгоритма используется рекурсия. Метод позволяет рекурсивно делить матрицы на подматрицы до тех пор, пока порядок не сранет равным 2. Далее происходит классическое умножение \cite{stras}.

Пусть $M(n)$ -- количество умножений, выполняемых алгоритмом Штрассена для умножения двух матриц размерами $n \times n$. Тогда для алгоритма Штрассена справедливо следующее рекуррентное соотношение \cite{stras2}:

\begin{equation}
	\label{eq:recmul}
	M(n) = 7 \cdot M(\frac{n}{2}) \hspace{0.25cm} \text{при} \hspace{0.25cm} n \ge 1, M(1) = 1
\end{equation}

\section{Оптимизированный алгоритм Штрассена для умножения двух матриц}

При программной реализации алгоритма Штрассена предлагается выполнить следующие оптимизации: 

\begin{enumerate}[label={\arabic*)}]
	\item Заменить умножение на 2 на побитовый сдвиг влево.
	\item Заменить выражение вида $x = x + k$ на выражение вида $x +\kern-0.25em= k$.
\end{enumerate}

\section*{Вывод}

В данном разделе были рассмотрены понятия матрицы и операции умножения, классического алгоритма умножения матриц и алгоритма умножения матриц с помощью алгоритма Винограда и Штрассена, а также были приведены варинты оптимизаций алгоритма Винограда и алгоритма Штрассена.
