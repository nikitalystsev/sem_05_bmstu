\chapter{Исследовательский раздел}

В данном разделе будут проведены сравнения реализаций алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна по времени работы и по затрачиваемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором проводились исследования: 

\begin{itemize}[label=--]
	\item операционная система: Ubuntu 22.04.3 LTS x86\_64 \cite{os};
	\item оперативная память: 16 Гб;
	\item процессор: 11th Gen Intel® Core™ i7-1185G7 @ 3.00GHz × 8.
\end{itemize}

\section{Время выполнения алгоритмов}

Время работы алгоритмов измерялось с использованием функции $clock\_gettime$ из встроенного модуля $ctime$. 

Замеры времени для каждой длины слов проводились 1000 раз. На вход подавались случайно сгенерированные строки заданной длины. 

Результаты замеров реализаций алгоритмов по времени представлены в таблице \ref{tbl:time}. Их графическое представление показано на рисунке \ref{img:linear_graph}.

% по точке выравнивание
\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Результаты замеров времени работы алгоритмов для строк с длиной от 1 до 10}
			\label{tbl:time}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Время, нс} \\ \cline{2-5}
				& \multicolumn{1}{c|}{\bfseries Левенштейн}
				& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейн} \\ \cline{2-5}
				\bfseries Длина, символ & \bfseries Итеративный & \bfseries Итеративный & \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{4-5}
				& & & \bfseries Без кеша & \bfseries С кешом \\
				\hline
				1 & 239.336 & 312.711 & 208.358 & 292.637 \\
				\hline
				2 & 355.681 & 388.345 & 416.912 & 481.743 \\
				\hline
				3 & 494.631 & 515.159 & 1214.162 & 657.416 \\
				\hline
				4 & 748.396 & 821.153 & 6253.184 & 1003.308 \\
				\hline
				5 &  1120.226 & 1133.970 & 30624.280 & 1444.514 \\
				\hline
				6 & 1479.574 & 1490.202 & 160402.600 & 2073.044 \\
				\hline
				7 & 2108.166 & 2012.790 & 898694.400 & 2785.704 \\
				\hline
				8 & 2624.444 & 2569.196 & 5036644.000 & 3623.980 \\
				\hline
				9 & 3770.614 & 3869.994 & 33096280.000 & 5633.132 \\
				\hline
				10 & 5394.930 & 5533.728 & 202570400.000 & 10068.464 \\
				\hline
			\end{tabular}
		\end{threeparttable}			
	\end{center}
\end{table}


\begin{figure}[h]
	\centering
	\includesvg[width=0.9\textwidth]{linear_graph}
	\caption{Результаты замеров времени работы алгоритмов для строк с длиной от 1 до 10}
	\label{img:linear_graph}
\end{figure}


%\includeimage
%{linear_graph} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
%{f} % Обтекание (без обтекания)
%{h} % Положение рисунка (см. figure из пакета float)
%{1\textwidth} % Ширина рисунка
%{Результаты замеров времени работы алгоритмов для строк с длиной от 1 до 10} % Подпись рисунка

\clearpage

Анализируя таблицу \ref{tbl:time}, сравним не рекурсивную реализацию алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. Можно заметить, что на любой длине входных строк от 1 до 10 нерекурсивная реализация алгоритма поиска расстояния Левенштейна работает быстрее нерекурсивной реализации алгоритма поиска расстояния Дамерау-Левенштейна. Это связано с тем, что в последнем алгоритме добавляется еще одно условие, которое увеличивает время его работы.

При рассмотрении рекурсивной и рекурсивной с кешированием реализаций алгоритмов поиска расстояний Левенштейна
можно увидеть, что, начиная со строки длиной в 3 символа, использование кеша в качестве сохранения промежуточных вычислений приводит к уменьшению времени работы почти в 2 раза, а к строке длиной в 10 символов -- в 20120 раз.

Сравнивая между собой нерекурсивную и рекурсивную с кешированием реализацию алгоритма поиска расстояний Левенштейна, можно заметить, что на любой длине входных строк от 1 до 10, рекурсивная с кешированием реализация работает медленнее нерекурсивной: начиная со строки длиной в 2 символа -- в 1.23 раза, а к строке длиной в 10 символов -- в 1.82 раза.

Таким образом, можно сказать, что при больших длинах строк лучше использовать итеративные алгоритмы, поскольку их рост линеен, в то время как  время рекурсивных алгоритмов растет экспоненциально.

\section{Использование памяти}

Введем следующие обозначения:
\begin{itemize}[label=--]
	\item$l_1$ --- длина строки $S_{1}$;
	\item$l_2$ --- длина строки $S_{2}$;
	\item$sizeof()$ --- функция вычисляющая размер в байтах;
	\item $wstring$ --- строковый тип;
	\item $int$ --- целочисленный тип;
	\item $size\_t$ --- беззнаковый целочисленный тип.
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации нахождения расстояния Дамерау-Левенштейна равна сумме входящих строк, а на каждый вызов требуется 2 дополнительные переменные, соответственно, максимальный расход памяти равен:

\begin{equation}
	\label{eq:dl_rec_memory}
	(l_1 + l_2) \cdot ( 2 \cdot sizeof(size\_t)  + 2 \cdot sizeof(int)) + 2 * sizeof(wstring),
\end{equation}

где:
\begin{itemize}[label=--]
	\item $2 \cdot sizeof(size\_t)$ --- хранение размеров строк;
	\item $2 \cdot sizeof(int)$ --- дополнительные переменные;
	\item $2 \cdot sizeof(wstring)$ --- хранение двух строк.
\end{itemize}

Расчет используемой памяти для рекурсивного алгоритма c кешированием поиска расстояния Дамерау-Левенштейна будет теоретически схож с расчетом в формуле \ref{eq:dl_rec_memory}, но также учитывается матрица, соответственно, максимальный расход памяти равен:

\begin{equation}
	\label{eq:dl_hash_memory}
	\begin{aligned}
		(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int) + sizeof(int **) + (l_1 + 1) \cdot sizeof(int *) + \\
		(l_1 + l_2) \cdot (2 \cdot sizeof(size\_t) + sizeof(int)) + 2 \cdot sizeof(wstring)
	\end{aligned}
\end{equation}

где 
\begin{itemize} [label=--]
	\item $(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение матрицы;
	\item $sizeof(int **)$ -- указатель на матрицу;
	\item $(l_1 + 1) \cdot sizeof(int *)$ -- указатель на строки матрицы;
	\item $2 \cdot size(size\_t)$ --- хранение размеров строк;
	\item $sizeof(int)$ --- дополнительная переменная;
	\item $2 * sizeof(wstring)$ --- хранение двух строк.
\end{itemize}

Расчет использования памяти при итеративной реализации алгоритма поиска расстояния Левенштейна теоретически равен:

\begin{equation}
	\label{eq:lev_mtr_memory}
	\begin{aligned}
		2 \cdot (l_2 + 1) \cdot sizeof(int) +  2 \cdot sizeof(wstring) + \\
		 2 \cdot sizeof(size\_t) + sizeof(int),
	\end{aligned}
\end{equation}

где 
\begin{itemize}[label=--]
	\item $2 \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение двух массивов;
	\item $2 \cdot size(wstring)$ --- хранение двух строк;
	\item $2 \cdot sizeof(size\_t)$ --- хранение размеров строк;
	\item $sizeof(int)$ --- дополнительная переменная.
\end{itemize}

Расчет использования памяти при итеративной реализации алгоритма поиска расстояния Дамерау-Левенштейна теоретически равен:

\begin{equation}
	\label{eq:dl_mtr_memory}
	\begin{aligned}
		(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int) + sizeof(int **) + (l_1 + 1) \cdot sizeof(int *) +  \\
		2 \cdot sizeof(wstring) + 2 \cdot sizeof(size\_t) + sizeof(int),
	\end{aligned}
\end{equation}

где 
\begin{itemize} [label=--]
	\item $(l_1 + 1) \cdot (l_2 + 1) \cdot sizeof(int)$ --- хранение матрицы;
	\item $sizeof(int **)$ -- указатель на матрицу;
	\item $(l_1 + 1) \cdot sizeof(int *)$ -- указатель на строки матрицы;
	\item $2 * sizeof(wstring)$ --- хранение двух строк;
	\item $2 \cdot size(size\_t)$ --- хранение размеров матрицы;
	\item $sizeof(int)$ --- дополнительная переменная.
\end{itemize}

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Замер памяти для строк, размером от 10 до 200}
			\label{tbl:memory}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Размер, байты} \\ \cline{2-5}
				& \multicolumn{1}{c|}{\bfseries Левенштейн}
				& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейн} \\ \cline{2-5}
				\bfseries Длина, символ & \bfseries Итеративный & \bfseries Итеративный & \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{4-5}
				& & & \bfseries Без кеша & \bfseries С кешом \\
				\hline
				10 & 252 & 748 & 624 & 1128 \\
				\hline
				20 & 412 & 2188 & 1184 & 2968 \\
				\hline
				30 & 572 & 4428 & 1744 & 5608 \\
				\hline
				40 & 732 & 7468 & 2304 & 9048 \\
				\hline
				50 & 892 & 11308 & 2864 & 13288 \\
				\hline
				60 &  1052 & 15948 & 3424 & 18328 \\
				\hline
				70 & 1212 & 21388 & 3984 & 24168 \\
				\hline
				80 &1372 & 27628 & 4544 & 30808 \\
				\hline
				90 & 1532 & 34668 & 5104 &  38248 \\
				\hline
				100 & 1692 & 42508 & 5664 & 46488 \\
				\hline
			\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\begin{figure}[h]
	\centering
	\includesvg[width=0.9\textwidth]{linear_graph_mem}
	\caption{Результаты вычислений используемой памяти реализаций алгоритмов для строк с длиной от 10 до 100}
	\label{img:linear_graph_mem}
\end{figure}


\clearpage

Анализируя таблицу \ref{tbl:memory}, сравним нерекурсивные реализации алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. При любой длине строки от 10 до 100 символов итеративный алгоритм поиска расстояния Левенштейна использует меньше памяти: при длине строки в 10 символов - в 3 раза меньше, а при длине строки в 100 символов уже в 25 раз. Такие результаты объясняются тем, что нерекурсивная реализация алгоритма поиска расстояния Дамерау-Левенштейна использует матрицу для сохранения ранее вычисленных значений, в то время как нерекурсивной реализации алгоритма поиска расстояния Левенштейна необходимы лишь текущая и предыдущая строки матрицы.

Сравнивая рекурсивную и рекурсивную с кешированием реализации алгоритмов поиска расстояний Левенштейна, можно увидеть, что использования матрицы в качестве кеша также приводит к быстрому росту используемой памяти в зависимости от длины входных строк.

При рассмотрении нерекурсивной и рекурсивной реализаций алгоритма поиска расстояний Дамерау-Левенштейна видно, что последняя с ростом длины строки использует в несколько раз меньше памяти, чем нерекурсивная: при длине строки в 10 символов -- в 1.2 раза меньше, а при длине строки в 100 символов -- в 7.5 раз меньше. Это связано с тем, что нерекурсивная реализация использует матрицу, в то время как рекурсивная использует только память, выделенную под локальные переменные при каждом рекурсивном вызове функции.

\section*{Вывод}

В данном разделе были проведены замеры времени работы а также расчеты используемой памяти реализаций алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. 

Итеративные реализации алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна работают быстрее рекурсивных, поскольку при итеративных реализациях не происходит многократного расчета одних и тех же промежуточных значений в ходе работы алгоритма.

Однако, рекурсивные алгоритмы более эффективные при использовании памяти, поскольку при использовании рекурсивной реализации происходит выделение памяти только под локальные переменные при каждом рекурсивном вызове.

Использование матрицы в качестве кеша в рекурсивной реализации алгоритма Дамерау-Левенштейна позволило сократить время работы алгоритма, но увеличило количество используемой памяти.

