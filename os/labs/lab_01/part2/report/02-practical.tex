\chapter{Пересчет динамических приоритетов}

Приоритет процесса зависит от количества используемого им процессорного времени и от того, на каком объекте ядра процесс был блокирован.

\section{Пересчет динамических приоритетов в семействе OC Windows}

При создании процессам назначается приоритет планирования. Приоритеты потоков являются относительными к приоритетам процессов.

В Windows реализуется приоритетная, вытесняющая система планирования, при которой всегда выполняется хотя бы один работоспособный (готовый) поток с самым высоким приоритетом.

Windows использует 32 уровня приоритета:

\begin{itemize}[label*=--]
	\item шестнадцать уровней реального времени (от 16 до 31);
	\item шестнадцать изменяющихся уровней (от 0 до 15), из которых уровень 0 зарезервирован для потока обнуления страниц.
\end{itemize}

% страницы, начиная с 478-й первой части Соломона Русиновича

Уровни приоритета потоков назначаются исходя из двух разных позиций:
одной от Windows API и другой от ядра Windows. 
Сначала Windows API систематизирует процессы по классу приоритета, который им присваивается при создании:

\begin{itemize}[label*=--]
	\item реального времени --- Real-time (4);
	\item высокий --- High (3);
	\item выше обычного --- Above Normal (6);
	\item обычный --- Normal (2);
	\item ниже обычного --- Below Normal (5);
	\item уровень простоя --- Idle (1).
\end{itemize}

Затем назначается относительный приоритет отдельных потоков внутри этих процессов. 
Здесь номера представляют изменение приоритета, применяющееся к базовому приоритету процесса:

\begin{itemize}[label*=--]
	\item критичный по времени --- Time-critical (15);
	\item наивысший --- Highest (2);
	\item выше обычного --- Above-normal (1);
	\item обычный --- Normal (0);
	\item ниже обычного --- Below-normal (-1);
	\item самый низший --- Lowest (-2);
	\item уровень простоя --- Idle (-15).
\end{itemize}

Соответствие между Windows-приоритетами и внутренними номерными приоритетами Windows показаны в таблице \ref{tbl:priority}.

\begin{table}[ht]
	\begin{center}
		\begin{threeparttable}
			\caption{Отображение приоритетов ядра Windows на Windows API}
			\label{tbl:priority}
			\begin{tabular}{|l|l|l|l|l|l|l|}
				\hline
				\bfseries \makecell{Класс приоритета/ \\ Относ-й приоритет} & \bfseries real-time & \bfseries high & \bfseries above &
				\bfseries normal & \bfseries \makecell{below \\ normal} & \bfseries idle \\
				\hline
				time critical & 31 & 15 & 15 & 15 & 15 & 15 \\
				\hline
				highest & 26 & 15 & 12 & 10 & 8 & 6 \\
				\hline
				above normal & 25 & 14 & 11 & 9 & 7 & 5 \\
				\hline
				normal & 24 & 13 & 10 & 8 & 6 & 4 \\
				\hline
				below normal & 23 & 12 & 9 & 7 & 5 & 3 \\
				\hline
				lowest & 22 & 11 & 8 & 6 & 4 & 2 \\
				\hline
				idle & 16 & 1 & 1 & 1 & 1 & 1 \\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

Повысить или понизить приоритет потока в динамическом диапазоне можно
в любом приложении, но для этого нужны привилегии, позволяющие повышать
приоритет, использующийся при планировании для ввода значения в пределах
динамического диапазона.

% страницы, начиная с 500-й первой части Соломона Русиновича

\subsection*{Повышение приоритета}

Планировщик Windows периодически изменяет текущий приоритет потоков, используя внутренний механизм повышения приоритета.

\subsubsection*{Повышение приоритета вследствие событий планировщика или диспетчера}

При наступлении события диспетчера, происходит вызов процедуры для обработки списка готовых потоков, отложенных на выполнение, при этом вызывающий код может указать какого типа повышение должно быть применено к потоку, а также с каким приращением приоритета должно быть связано это повышение.

\subsubsection*{Повышения приоритета, связанные с завершением ожидания}

При пробуждении потока и перемещении его в очередь готовых к исполнению, его приоритет должен быть повышен, чтобы поток как можно скорее начал выполняться.

\subsubsection*{Повышение приоритета после завершения ввода-вывода}

Windows дает временное повышение приоритета при завершении определенных операций ввода/вывода, при этом потоки, ожидавшие ввода/вывода, имеют больше шансов сразу же запуститься и обработать то, чего они ожидали.
В таблице \ref{tbl:io} перечислены рекомендуемые значение повышения приоритета.

\begin{table}[ht]
	\begin{center}
		\begin{threeparttable}
			\caption{Рекомендуемые значение повышения приоритета}
			\label{tbl:io}
		\begin{tabularx}{\textwidth}{|p{100mm}|X|}
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\
			\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\
			\hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
			\hline
			Клавиатура, мышь & 6 \\
			\hline
			Звуковая плата & 8 \\
			\hline
		\end{tabularx}
	\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\subsubsection*{Повышение при ожидании ресурсов исполняющей системы}

Когда поток пытается получить ресурс, уже находящийся в исключительном владении, он переходит в режим ожидания, пока ресурс не будет освобожден. 
Система ограничивает длительность этого ожидания, выполняя его интервально каждые 500 мс. 
Если ресурс остается недоступным даже после этого времени, система предотвращает блокировку процессора путем изменения приоритета потоков и выполнения дополнительных ожиданий.

\subsubsection*{Повышение приоритета потоков первого плана после ожидания}

Предоставление небольшого повышения приоритета приложениям первого плана по окончании ожидания способствует более оперативному началу их работы, особенно в ситуациях, когда другие процессы с тем же базовым приоритетом могут быть запущены в фоновом режиме.

\subsubsection*{Повышение приоритета после пробуждения GUI-потока}

Потоки --- владельцы окон получают при пробуждении дополнительное повышение приоритета на 2 из-за активности при работе с окнами, например, при поступлении сообщений от окна.

\subsubsection*{Повышения приоритета, связанные с перезагруженностью центрального процессора (CPU Starvation)}

Одна из частей потока, которую называют диспетчером настройки баланса (ДНБ), несёт функцию  ослабления загруженности центрального процессора. 
ДНБ сканирует очередь готовых потоков раз в секунду и, если обнаружены потоки, ожидающие выполнения более 4 секунд, то диспетчер настройки баланса повышает их приоритет до 15. 
Как только квант истекает, приоритет потока снижается до базового приоритета. 
Если поток не был завершен за квант времени или был вытеснен потоком с более высоким приоритетом, то после снижения приоритета поток возвращается в очередь готовых потоков.

\subsubsection*{Повышения приоритетов для мультимедийных приложений и игр}

Для решения проблемы вытеснения потоков, на которых выполняются мутимедийные приложения и игры, в Windows используют драйвер MMCSS (MultiMedia Class Scheduler Service). 
Клиентские приложения регистрируются у MMCSS, передавая имя задачи, например, аудио, игры, воспроизведение и др.  
Одно из наиболее важных свойств для планирования потоков называется категорией планирования (Scheduling Category) --- это основной фактор, определяющий приоритет потоков, зарегистрированных с MMCSS.
В таблице \ref{tbl:plan} показаны различные категории планирования.


\begin{table}[ht]
	\centering
	\begin{threeparttable}
		\caption{Категории планирования}
		\label{tbl:plan}
		\begin{tabularx}{\textwidth}{|X|X|p{80mm}|}
			\hline
			\bfseries Категория & \bfseries Приоритет & \bfseries Описание \\
			\hline
			High (Высокая) & 23-26 & Потоки профессионального аудио (Pro Audio), запущенные с приоритетом выше, чем у других потоков на системе, за исключением критических системных потоков \\
			\hline
			Medium (Средняя) & 16-22 & Потоки, являющиеся частью приложений первого плана, например Windows Media Player \\
			\hline
			Low (Низкая) & 8-15 & Все остальные потоки, не являющиеся частью предыдущих категорий \\
			\hline
			Exhausted (Исчерпавших потоков) & 1-7 & Потоки, исчерпавшие свою долю времени центрального процессора, выполнение которых продолжится, только если не будут готовы к выполнению другие потоки с более высоким уровнем приоритета \\
			\hline
		\end{tabularx}
	\end{threeparttable}
\end{table}

\clearpage

\section{Пересчет динамических приоритетов в семействе OC UNIX/Linux}

Приоритет процесса задается любым целым числом, лежащим в диапазоне от 0 до 127. 
Чем меньше такое число, тем выше приоритет. 
Приоритеты от 0 до 49 зарезервированы для ядра, следовательно, прикладные процессы могут обладать приоритетом в диапазоне 50-127. 

Структура $proc$ содержит следующие поля, которые относятся к приоритетам:

\begin{itemize}[label*=--]
	\item $p\_runpri$ --- приоритет выполнения процесса в текущий момент времени;
	\item $p\_slppri$ --- приоритет, который используется для упорядочения процессов в состоянии ожидания;
	\item $p\_usrpri$ --- приоритет режима задачи;
	\item $p\_estcpu$ --- результат последнего измерения использования процессора;
	\item $p\_nice$ --- фактор <<любезности>>, который устанавливается пользователем.
\end{itemize}

Планировщик использует $p\_runpri$ для принятия решения о том, какой процесс направить на выполнение, а именно для хранения временного приоритета для выполнения в режиме ядра.

Поле $p\_usrpri$ используется для хранения приоритета, который будет назначен процессу при возврате в режим задачи из состояния блокировки. 

У событий или объектов ядра, на которых может быть блокирован процесс, определён приоритет сна. 
Приоритет сна являтся величиной, определяемой для ядра, и потому лежит в диапазоне 0-49.

\clearpage

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\caption{Системные приоритеты сна}
			\label{tbl:sbsd}
			\begin{tabular}{ |c|c|p{9cm}|  }
				\hline
				\textbf{4.3BSD UNIX} & \textbf{SCO UNIX} & \textbf{Событие} \\
				\hline
				\texttt{0} & 95 & Ожидание загрузки в память сегмента/страницы (свопинг, страничное замещение) \\
				\hline
				\texttt{10} & 88 & Ожидание индексного дескриптора \\
				\hline
				\texttt{20} & 81 & Ожидание ввода-вывода \\
				\hline
				\texttt{30} & 80 & Ожидание буфера \\
				\hline
				\texttt{-} & 75 & Ожидание терминального ввода \\
				\hline
				\texttt{-} & 74 & Ожидание терминального вывода \\
				\hline
				\texttt{-} & 73 & Ожидание завершения выполнения \\
				\hline
				\texttt{40} & 66 & Ожидание события --- низкоприоритетное состояние сна \\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}

	\vspace{1cm} % Расстояние между таблицами
	
	\begin{center}
		\begin{threeparttable}
			\caption{Приоритеты сна в ОС \textbf{4.3BSD}}
			\label{tbl:bsd}
			\begin{tabular}{|c|c|c|}
				\hline
				\textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\
				\hline
				\texttt{PSWP} & 0 & Свопинг \\
				\hline
				\texttt{PSWP + 1} & 1 & Страничный демон \\
				\hline
				\texttt{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
				\hline
				\texttt{PINOD} & 10 & Ожидание освобождения inode \\
				\hline
				\texttt{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
				\hline
				\texttt{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
				\hline
				\texttt{PZERO} & 25 & Базовый приоритет \\
				\hline
				\texttt{TTIPRI} & 28 & Ожидание ввода с терминала \\
				\hline
				\texttt{TTOPRI} & 29 & Ожидание вывода с терминала \\
				\hline 
				\texttt{PWAIT} & 30 & Ожидание завершения процесса потомка \\
				\hline
				\texttt{PLOCK} & 35 & Консультативное ожидание блок. ресурса \\
				\hline
				\texttt{PSLEP} & 40 & Ожидание сигнала \\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

Можно выделить следующие особые ситуации, связанные с изменением полей $p\_usrpri$ и  $p\_runpri$:

\begin{itemize}[label*=--]
	\item когда процесс находится в режиме задачи, то его значения полей $p\_usrpri$ и $p\_runpri$ равны;
	\item когда процесс просыпается после блокирования, то есть происходит его постановка в очередь готовых процессов, его приоритету $p\_runpri$ присваивается значение приоритета сна события или ресурса, на котором он был блокирован, чтобы дать процессу предпочтение для выполнения в режиме ядра;
	\item когда процесс завершил выполнение системного вызова и находится в состоянии возврата в режим задачи, его приоритет $p\_runpri$ сбрасывается обратно в значение текущего приоритета в режиме задачи $p\_usrpri$.
\end{itemize}

Приоритет в режиме задачи зависит от двух факторов: <<любезности>> ($p\_nice$) и последней измеренной величины использования процессора ($p\_estcpu$). 

Степень любезности ($nice$ $value$) является числом в диапазоне от 0 до 39 со значением 20 по умолчанию. Увеличение значения приводит к уменьшению приоритета.

Каждую секунду ядро системы инициализирует отложенный вызов процедуры $schedcpu()$, которая уменьшает значение $p\_runpri$ каждого процесса исходя из фактора <<полураспада>> ($decay$ $factor$). В системе SVR3 используется фиксированное значение этого фактора, равное $\frac{1}{2}$.

В 4.3BSD фактор полураспада рассчитывается по формуле \ref{eq:ref1}:

\begin{equation}
	\label{eq:ref1}
	decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
\end{equation} 
где \textit{load\_average} --- это среднее количество процессов, находящихся в состоянии готовности к выполнению, за последнюю секунду.

\clearpage

Также процедура $schedcpu()$ пересчитывает приоритеты для режима задачи всех процессов по формуле \ref{eq:ref2},

\begin{equation}
	\label{eq:ref2}
	p\_usrpri = PUSER + \frac{p\_estcpu}{4} + 2 \cdot p\_nice
\end{equation}где \textit{PUSER} - базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс в последний раз использовал большое количество процессорного времени, то его $р\_estсрu$ будет увеличен. Исходя из формулы \ref{eq:ref2}, значение $p\_estcpu$ увеличится, соответственно приоритет процесса понизится.  
Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор полураспада уменьшает его $р\_estсрu$, что приводит к повышению его приоритета. 

Такая схема предотвращает бесконечное откладывание процессов. 
Применение данной схемы предпочтительно процессам, осуществляющим много операций ввода-вывода, в противоположность процессам, производящим много вычислений. 
То есть динамический пересчет приоритетов процессов в режиме задачи позволяет избежать бесконечного откладывания.


\chapter*{Вывод}
\addcontentsline{toc}{chapter}{Вывод}

Функции обработчика прерывания от системного таймера в операционных системах семейства UNIX/Linux и семейства Windows выполняют схожие задачи, поскольку системы обоих семейств являются являются системами разделения времени с вытеснением и динамически управляемыми приоритетами:

\begin{itemize}[label*=--]
	\item декремент кванта;
	\item инициализация отложенных действий, таких как активация планировщика;
	\item декремент счетчиков времени.
\end{itemize}