/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "bakery.h"
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

time_t raw_time;
struct tm *timeinfo;

int choosing[26] = {0};
int number[26] = {0};
int symbol = 'a';
int idx = 0;

struct bakery_t threadsResults[26] = {0};
pthread_t workers[26];
int idxThreadCreate = 0;
int idxThreadJoin = 0;

int getMaxNumber()
{
    int currMax = number[0];

    for (int i = 1; i < 26; i++)
        if (number[i] > currMax)
            currMax = number[i];

    return currMax;
}

void *bakery(void *arg)
{
    time(&raw_time);
    timeinfo = localtime(&raw_time);

    struct bakery_t *targ = arg;

    printf("Thread (id = %d) started, номер клиента = %d, time = %s", gettid(), number[targ->idx], asctime(timeinfo));

    int i = targ->idx;
    for (int j = 0; j < 26; j++)
    {
        while (choosing[j])
            ;
        while ((number[j] > 0) && (number[j] < number[i] || (number[j] == number[i] && j < i)))
            ;
    }

    targ->result = symbol;
    symbol++;

    sleep(5);
    time(&raw_time);
    timeinfo = localtime(&raw_time);
    printf("Thread (id = %d) stopped, номер клиента = %d, time = %s", gettid(), number[i], asctime(timeinfo));

    number[i] = 0;

    return 0;
}

struct bakery_t *
get_number_1_svc(struct bakery_t *argp, struct svc_req *rqstp)
{
    static struct bakery_t result;

    printf("Клиент (pid = %d) залогинился на сервере\n", argp->pid);

    choosing[idx] = true;
    number[idx] = getMaxNumber() + 1;
    choosing[idx] = false;

    result.number = number[idx];
    result.pid = argp->pid;
    result.idx = idx;

    idx++;

    return &result;
}

struct bakery_t *
wait_queue_1_svc(struct bakery_t *argp, struct svc_req *rqstp)
{
    static struct bakery_t result;

    threadsResults[idxThreadCreate].number = argp->number;
    threadsResults[idxThreadCreate].pid = argp->pid;
    threadsResults[idxThreadCreate].idx = argp->idx;

    pthread_create(&workers[idxThreadCreate], NULL, bakery, &threadsResults[idxThreadCreate]);

    idxThreadCreate++;

    return &result;
}

struct bakery_t *
bakery_res_1_svc(struct bakery_t *argp, struct svc_req *rqstp)
{
    static struct bakery_t result;

    pthread_join(workers[idxThreadJoin], NULL);

    result.number = argp->number;
    result.pid = argp->pid;
    result.idx = argp->idx;
    result.result = threadsResults[idxThreadJoin].result;

    idxThreadJoin++;

    return &result;
}
